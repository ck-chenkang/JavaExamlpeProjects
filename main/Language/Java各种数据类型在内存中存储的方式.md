# java中的各种数据类型在内存中存储的方式

参考链接：[java中的各种数据类型在内存中存储的方式]（https://blog.csdn.net/zj15527620802/article/details/80622314）

## java是如何管理内存的

java内存的管理就是对象的分配和释放问题，包含两部分：

1、分配：内存的分配都是由程序完成的，程序员需要通过关键字new为每个对象申请内存空间（基本类型除外），所有的对象都是在堆(Heap)中分配空间。

2、释放：对象的释放是由垃圾回收机制决定和执行的，这样做确实简化了程序员的工作，但同时，它也加重了JVM的工作。因为，GC为了能够正确的释放对象，GC必须监控每一个对象的运行状态，包括对象的申请、
引用、被引用、赋值等。

## 什么叫java内存泄漏

在java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：

1、首先，这些对象是可达的，即在有向图中，存在通路可以与其相连（也就是说仍存在该内存对象的引用）；
2、其次，这些对象是无用的，即程序以后不会再使用这些对象。

如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

## JVM的内存区域组成

java把内存分两种：一种是栈内存，另一种是堆内存

(1)在函数中定义的基本类型变量和对象的引用变量都在函数的栈内存中分配；

(2)堆内存用来存放由new创建的对象和数组以及对象的实例变量。

在函数（代码块）中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量所分配的内存空间；

在堆中分配的内存由java虚拟机的自动垃圾回收器来管堆和栈的优缺点

堆的优势是可以动态分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的。

缺点就是要在运行时动态分配内存，存取速度较慢；栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。

另外，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

## java中数据在内存中是如何存储的

### 基本数据类型
 
java的基本数据类型共有8种，即int,short,long,byte,float,double,boolean,char(注意，并没有String的基本类型 )。
这种类型的定义是通过诸如int a = 3；long b = 255L；的形式来定义的。如int a = 3；
这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，
由于大小可知，生存期可知(这些字面值定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。
 
另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。比如：
我们同时定义：
 
int a=3;
int b=3;
 
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。
接着处理int b = 3；在创建完b这个引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。
 
定义完a与b的值后，再令a = 4；那么，b不会等于4，还是等于3。在编译器内部，遇到时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；
如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

### 对象

在java中，创建一个对象包括对象的声明和实例化两步，下面用一个例题来说明对象的内存模型。假设有类Rectangle定义如下：

```java
public class Rectangle {
double width;
double height;
public Rectangle( double w, double h){
w = width;
h = height;
}
}
```

(1)声明对象时的内存模型
用Rectangle rect；声明一个对象rect时，将在栈内存为对象的引用变量rect分配内存空间，但Rectangle的值为空，称rect是一个空对象。空对象不能使用，因为它还没有引用任何”实体”。

(2)对象实例化时的内存模型
当执行rect=new Rectangle(3,5)；时，会做两件事：
1、在堆内存中为类的成员变量width,height分配内存，并将其初始化为各数据类型的默认值；接着进行显式初始化（类定义时的初始化值）；
2、最后调用构造方法，为成员变量赋值。返回堆内存中对象的引用（相当于首地址）给引用变量rect,以后就可以通过rect来引用堆内存中的对象了。

### 创建多个不同的对象实例

一个类通过使用new运算符可以创建多个不同的对象实例，这些对象实例将在堆中被分配不同的内存空间，改变其中一个对象的状态不会影响其他对象的状态。例如：

Rectangle r1= new Rectangle(3,5);
Rectangle r2= new Rectangle(4,6);

此时，将在堆内存中分别为两个对象的成员变量 width 、 height 分配内存空间，两个对象在堆内存中占据的空间是互不相同的。如果有：

Rectangle r1=new Rectangle(3,5);
Rectangle r2=r1;

则在堆内存中只创建了一个对象实例，在栈内存中创建了两个对象引用，两个对象引用同时指向一个对象实例。

### 包装类

基本类型都有对应的包装类：如int对应Integer类，double对应Double类等，基本类型的定义都是直接在栈中，如果用包装类来创建对象，就和普通对象一样了。
例如：int i=0；i直接存储在栈中。Integer i（i此时是对象）= new Integer(5)；这样，i对象数据存储在堆中，i的引用存储在栈中，通过栈中的引用来操作对象。


### String

String是一个特殊的包装类数据。可以用以下两种方式创建：String str = new String(“abc”)；String str = “abc”;
第一种创建方式，和普通对象的的创建过程一样；
第二种创建方式，java内部将此语句转化为以下几个步骤：
(1)先定义一个名为str的对String类的对象引用变量：String str；
(2)在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”
地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈
这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并
回o的地址。
(3)将str指向对象o的地址。
值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种
合下，其字符串值却是保存了一个指向存在栈中数据的引用。
为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。

 
String str1="abc"；
String str2="abc"；
System.out.println(s1==s2)；//true
注意，这里并不用 str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。
我们再接着看以下的代码。

 
String str1= new String("abc")；
String str2= "abc"；
System.out.println(str1==str2)；//false
创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。
以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。

### 数组

当定义一个数组，int x[]；或int[] x；时，在栈内存中创建一个数组引用，通过该引用（即数组名）来引用数组。
x=new int[3]；将在堆内存中分配3个保存 int型数据的空间，堆内存的首地址放到栈内存中，每个数组元素被初始化为0。

### 静态变量

用static的修饰的变量和方法，实际上是指定了这些变量和方法在内存中的”固定位置”－static storage，可以理解为所有实例对象共有的内存空间。
static变量有点类似于C中的全局变量的概念；静态表示的是内存的共享，就是它的每一个实例都指向同一个内存地址。
把static拿来，就是告诉JVM它是静态的，它的引用（含间接引用）都是指向同一个位置，在那个地方，你把它改了，它就不会变成原样，你把它清理了，它就不会回来了。

那静态变量与方法是在什么时候初始化的呢？对于两种不同的类属性，static属性与instance属性，初始化的时机是不同的。
instance属性在创建实例的时候初始化，static属性在类加载，也就是第一次用到这个类的时候初始化，对于后来的实例的创建，不再次进行初始化。

我们常可看到类似以下的例子来说明这个问题：

 
class Student{
static int numberOfStudents =0;
Student()
{
numberOfStudents ++;
}
}
每一次创建一个新的Student实例时,成员numberOfStudents都会不断的递增,并且所有的Student实例都访问同一个numberOfStudents变量,实际上intnumberOfStudents变量在内存中只存储在一个位置上。

## java内存管理实例

Java程序的多个部分(方法，变量，对象)驻留在内存中以下两个位置：即堆和栈，现在我们只关心三类事物：实例变量，局部变量和对象：
实例变量和对象驻留在堆上
局部变量驻留在栈上
让我们查看一个 java 程序，看看他的各部分如何创建并且映射到栈和堆中：

 ```
public class Dog {
Collar c;
String name;
//1.main()方法位于栈上
public static void main(String[] args) {
//2.在栈上创建引用变量d,但Dog对象尚未存在
Dog d;
//3.创建新的Dog对象，并将其赋予d引用变量
d = new Dog();
//4.将引用变量的一个副本传递给go()方法
d.go(d);
}
//5.将go()方法置于栈上，并将dog参数作为局部变量
void go(Dog dog){
//6.在堆上创建新的Collar对象，并将其赋予Dog的实例变量
c = new Collar();
}
//7.将setName()添加到栈上，并将dogName参数作为其局部变量
void setName(String dogName){
//8.name的实例对象也引用String对象
name =dogName;
}
//9.程序执行完成后，setName()将会完成并从栈中清除，此时，局部变量dogName也会消失，尽管它所引用的String仍在堆上
}
```





